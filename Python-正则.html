<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>商伟的技术博客</title>
	<meta name="description" content="">
	<meta name="author" content="商伟">

	<!-- HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="/theme/html5.js"></script>
	<![endif]-->

	<!-- Styles -->
	<link href="/theme/bootstrap.min.css" rel="stylesheet">
	<link href="/theme/local.css" rel="stylesheet">
	<link href="/theme/pygments.css" rel="stylesheet">

	<!-- Feeds -->




</head>
<body>
	<div class="topbar">
	  <div class="topbar-inner">
		<div class="container-fluid">
		  <a class="brand" href="/">商伟的技术博客</a>
			<ul class="nav">
					<li ><a href="/category/django.html">Django</a></li>
					<li ><a href="/category/git.html">GIT</a></li>
					<li ><a href="/category/javascript.html">JavaScript</a></li>
					<li ><a href="/category/mongodb.html">Mongodb</a></li>
					<li ><a href="/category/mysql.html">MySQL</a></li>
					<li ><a href="/category/pa-chong.html">爬虫</a></li>
					<li class="active"><a href="/category/python.html">Python</a></li>
					<li ><a href="/category/rabbitmq.html">RabbitMQ</a></li>
					<li ><a href="/category/redis.html">redis</a></li>
					<li ><a href="/category/sui-shou-bi-ji.html">随手笔记</a></li>
					<li ><a href="/category/supervisor.html">Supervisor</a></li>
					<li ><a href="/category/vue.html">VUE</a></li>
					<li ><a href="/category/wang-luo.html">网络</a></li>
					<li ><a href="/category/xiao-cheng-xu.html">小程序</a></li>
					<li ><a href="/category/xu-ni-huan-jing.html">虚拟环境</a></li>
			</ul>
			<p class="pull-right"><a href="/archives.html">[archives]</a> <a href="/tags.html">[tags]</a></p>
		</div>
	  </div>
	</div>

	<div class="container-fluid">
	  <div class="sidebar">
		<div class="well">
			<h3>Blogroll</h3>
			<ul>
				<li><a href="http://getpelican.com/">Pelican</a></li>
				<li><a href="http://python.org/">Python.org</a></li>
				<li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
				<li><a href="https://shangxiaoweia.github.io/puzzle.html">拼图</a></li>
			</ul>
			<div class="social">
			<h3>Social</h3>
			<ul>
				<li><a href="https://han520min.github.io">hanmin</a></li>
			</ul>
			</div>
		</div>
	  </div>
	  <div class="content">
	<div class='article'>
		<div class="page-header"><h1>Python-正则</h1></div>
		<div class="well small">Permalink: <a class="more" href="/Python-正则.html">1000-01-10 18:44:00+00:09</a>
by <a class="url fn" href="/author/shang-wei.html">商伟 </a>
 in <a href="/category/python.html">Python</a>
tags: <a href="/tag/python.html">Python</a> </div>
		<div><h3>正则</h3>
<blockquote>
<p>一些特殊符号及文本组合在一起的用来描述字符或字符串的一些规则，叫做正则</p>
</blockquote>
<h4>正则中的特殊符号</h4>
<blockquote>
<p><strong>匹配一个范围</strong>： <strong>[]</strong>
<strong>[A-Z]</strong>：A, B, C…
<strong>[0-9]</strong>：1, 2, 3…</p>
</blockquote>
<hr>
<blockquote>
<p><strong>匹配任何数字字符</strong>：<strong>\d</strong>
<strong>\d</strong>：1, 2, 3…</p>
</blockquote>
<hr>
<blockquote>
<p><strong>匹配任何空白符</strong>：<strong>\s</strong>
<strong>\s</strong>：\t (水平制表), \v (垂直制表), \n (换行), \r (回车), \f (换页)</p>
</blockquote>
<hr>
<blockquote>
<p><strong>匹配任何数字、字母、字符及下划线</strong>：<strong>\w</strong>
<strong>\w</strong>： a, 1, _</p>
</blockquote>
<hr>
<blockquote>
<p><strong>匹配除了换行符任意一个单个字符</strong>：<strong>.</strong>
a<strong>.</strong>c：abc, a2c, a_c
<strong>..</strong>：匹配任意字符组成的两个长度的字符串</p>
</blockquote>
<hr>
<blockquote>
<p><strong>匹配前面出现的正则表达式0次或多次</strong>：<strong><em>*</em></strong>
a<strong><em>*</em>：aaa 或是一个空
[abc]</strong>*：aaabbb abc bbaacc</p>
</blockquote>
<hr>
<blockquote>
<p><strong>匹配前面出现的正则表达式0次或一次</strong>：<strong>?</strong>
<strong>a?</strong>：a 或是一个空</p>
</blockquote>
<hr>
<blockquote>
<p><strong>匹配前面出现的正则表达式1次或多次</strong>：<strong>+</strong>
<strong>a+</strong>：aaa a
<strong>abc+</strong>：abcabc</p>
</blockquote>
<hr>
<blockquote>
<p><strong>匹配前面出现的正则表达式固定次数</strong>：<strong>{}</strong>
<strong>a{5}</strong>： aaaaa
<strong>\d{5}</strong>：12345, 22222</p>
</blockquote>
<hr>
<blockquote>
<p><strong>匹配明确的多个选择</strong>：<strong>|</strong>
<strong>a | b</strong>：a, b
<strong>abc|cdf|123</strong>：abc, cdf, 123</p>
</blockquote>
<hr>
<blockquote>
<p><strong>匹配字符串的开头或结尾</strong>：<strong>^, $</strong>
<strong>^abc</strong>：匹配所有以abc开头的字符串
<strong>abc$</strong>：匹配所有以abc结尾的字符串</p>
</blockquote>
<hr>
<blockquote>
<p><strong>否定匹配</strong>：<strong>[^]</strong>
<strong>[^a]</strong>：匹配除了a之外的所有字符</p>
</blockquote>
<hr>
<h4>re模块函数</h4>
<blockquote>
<p><strong>re.compile(pattern)</strong>
编译正则表达式
一般的，特殊字符再进行正则匹配的时候，如果你不预先编译正则表达式，解释器也会在你传入参数的时候进行编译
一些常用正则表达式，我们可以提前使用该函数进行预先编译，提高程序的效率</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">re</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">)</span>
</pre></div>


<hr>
<blockquote>
<p><strong>re.match(pattern,string)</strong>
尝试使用正则模式<strong>pattern</strong>在字符串中的开头进行严格匹配，如果开头匹配失败则匹配失败
<strong>匹配成功</strong>：返回一个匹配对象，匹配到的值可通过<strong>group</strong>函数获取
<strong>匹配失败</strong>：返回<strong>None</strong></p>
</blockquote>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; res = re.match(&#39;abc&#39;,&#39;abcac&#39;)
&lt;_sre.SRE_Match object; span=(0, 3), match=&#39;abc&#39;&gt; #返回表示选择的区间以及匹配到的结果
&gt;&gt;&gt; &gt;&gt;&gt; res.group()
&#39;abc&#39;
</pre></div>


<hr>
<blockquote>
<p><strong>re.findall(pattern,string)</strong>
返回字符串中正则模式的所有非重复出现</p>
</blockquote>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; re.findall(&#39;\*&#39;,&#39;a*b*c*&#39;)
[&#39;*&#39;, &#39;*&#39;, &#39;*&#39;]
</pre></div>


<blockquote>
<p><strong>注意</strong>：由于匹配的表达式中，我希望匹配的只是单纯的<strong>*</strong>号，并不具有特殊意义，所以要加一个斜杠防止转义</p>
</blockquote>
<hr>
<blockquote>
<p><strong>re.search(pattern,string)</strong>
返回字符串中正则模式的第一次出现，没有匹配结果则返回<strong>None</strong>
结果可以通过返回值的group函数获取</p>
</blockquote>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; res = re.search(&#39;\*&#39;,&#39;a*b*c*&#39;)
&lt;_sre.SRE_Match object; span=(1, 2), match=&#39;*&#39;&gt;
&gt;&gt;&gt; res.group()
&#39;*&#39;
</pre></div>


<hr>
<blockquote>
<p><strong>re.sub(str1,str2,str3)</strong>
<strong>re.subn(str1,str2,str3)</strong>
<strong>str1</strong>：要替换的字符串
<strong>str2</strong>：替换成什么
<strong>str3</strong>：在哪个字符串里进行替换</p>
</blockquote>
<hr>
<blockquote>
<p>这两个函数都可以实现<strong>搜索</strong>和<strong>替换</strong>功能，均返回一个替换之后的新字符串
<strong>subn</strong>函数会以元组形式包含一个表示替换的总数</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">var</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;\*&#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39;a*b*c*&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">var</span>
<span class="s1">&#39;a_b_c_&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">var</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">subn</span><span class="p">(</span><span class="s1">&#39;\*&#39;</span><span class="p">,</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39;a*b*c*&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">var</span>
<span class="p">(</span><span class="s1">&#39;a_b_c_&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>


<hr>
<h4>贪婪非贪婪</h4>
<p>如果<strong>问号<strong><em>*?</em>*紧跟在任何使用</strong>闭合</strong>（类似<strong><em> +</em>* 这样的操作符）的匹配后面， 它将直接要求正则表达式引擎匹配</strong>尽可能少<strong>的次数，这叫做</strong>非贪婪**</p>
<p><strong>贪婪匹配</strong>：正则表达式引擎将试图“吸收”匹配该模式的<strong>尽可能多</strong>的字符
<strong>非贪婪匹配</strong>：问号要求正则表达式引擎去<strong>“偷懒”</strong>，如果可能，就在当前的正则表达式中尽<strong>可能少</strong>地匹配字符，留下尽可能多的字符给后面的模式</p>
<hr>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; import re
&gt;&gt;&gt; mystr = &#39;a*b*c*d*e*f*g&#39;ac
&gt;&gt;&gt; re.findall(&#39;.+?&#39;, mystr) #非贪婪模式进行匹配
[&#39;a&#39;, &#39;*&#39;, &#39;b&#39;, &#39;*&#39;, &#39;c&#39;, &#39;*&#39;, &#39;d&#39;, &#39;*&#39;, &#39;e&#39;, &#39;*&#39;, &#39;f&#39;, &#39;*&#39;, &#39;g&#39;]
&gt;&gt;&gt; re.findall(&#39;.+&#39;, mystr) #贪婪模式进行匹配
[&#39;a*b*c*d*e*f*g&#39;]
&gt;&gt;&gt; re.findall(&#39;.*&#39;, mystr) #贪婪模式进行匹配
[&#39;a*b*c*d*e*f*g&#39;, &#39;&#39;]
&gt;&gt;&gt; re.findall(&#39;.*?&#39;, mystr) #非贪婪模式进行匹配
[&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;] #结果不同在于对+号和*号特殊字符的解释
</pre></div></div>
	</div>
		<footer>
		  <p>Powered by <a href="http://getpelican.com/">Pelican</a>. Theme based on <a href="http://twitter.github.com/bootstrap/">Twitter Bootstrap</a>.</p>
		  <p>&copy; 商伟</p>
		</footer>
	  </div>

	</div>
</body>
</html>